// Generated by CoffeeScript 1.9.3
var _blacklistUrl, _getProtocol_Domain_Path, _tryDomain, _unblacklistUrl, addToHttpList, addToHttpsList, blacklist, blacklistUrl, forward_to, httplist, httpslist, query, tryHttps, unblacklistUrl,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

blacklist = [];

httpslist = [];

httplist = [];

chrome.runtime.onMessage.addListener(function(request, sender, callback) {
  if (request.type === 'blacklist') {
    console.log('blacklisting...');
    _blacklistUrl();
  }
  if (request.type === 'unblacklist') {
    console.log('unblacklisting...');
    return _unblacklistUrl();
  }
});

query = {
  active: true,
  currentWindow: true
};

_unblacklistUrl = function() {
  return chrome.tabs.query(query, function(tabs) {
    var currentTab;
    currentTab = tabs[0];
    console.log(currentTab);
    console.log('unblacklisting ' + currentTab.url);
    return unblacklistUrl(currentTab.url);
  });
};

_blacklistUrl = function() {
  return chrome.tabs.query(query, function(tabs) {
    var currentTab;
    currentTab = tabs[0];
    console.log(currentTab);
    return blacklistUrl(currentTab.url);
  });
};

unblacklistUrl = function(url) {
  var domain, index;
  domain = _getProtocol_Domain_Path(url)[1];
  if (indexOf.call(blacklist, domain) >= 0) {
    console.log('filtering...');
    index = blacklist.indexOf(domain);
    blacklist.splice(index, index !== -1 ? 1 : void 0);
    console.log.apply(console, ['new blacklist'].concat(slice.call(blacklist)));
    alert('unblacklisted ' + domain);
  } else {
    return console.log('not in blacklist');
  }
};

blacklistUrl = function(url) {
  var domain;
  domain = _getProtocol_Domain_Path(url)[1];
  if (indexOf.call(blacklist, domain) < 0) {
    blacklist.push(domain);
    console.log.apply(console, ['new blacklist'].concat(slice.call(blacklist)));
    alert('blacklisted ' + domain);
  } else {
    return console.log('already in blacklist');
  }
};

addToHttpsList = function(url) {
  var domain;
  domain = _getProtocol_Domain_Path(url)[1];
  if (indexOf.call(httpslist, domain) < 0) {
    httpslist.push(domain);
    console.log.apply(console, ['new httpslist'].concat(slice.call(httpslist)));
  }
};

addToHttpList = function(url) {
  var domain;
  domain = _getProtocol_Domain_Path(url)[1];
  if (indexOf.call(httplist, domain) < 0) {
    httplist.push(domain);
    return console.log.apply(console, httplist);
  }
};

_tryDomain = function(domain, path, tabId, forward) {
  var got_2xx, xhr;
  if (forward == null) {
    forward = true;
  }
  xhr = new XMLHttpRequest();
  xhr.open("GET", "https://" + domain, true);
  got_2xx = false;
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 2) {
      if (xhr.status >= 200 && xhr.status < 300) {
        got_2xx = true;
        addToHttpsList('https://' + domain);
        if (forward) {
          return forward_to('https://' + [domain, path].join('/'), tabId);
        }
      }
    }
  };
  xhr.timeout = 10000;
  xhr.ontimeout = function() {
    got_2xx = false;
    console.log('no https for ' + domain);
    return addToHttpList('http://' + domain);
  };
  xhr.send();
  return got_2xx;
};

_getProtocol_Domain_Path = function(url) {
  var arr, dom, path, prot;
  arr = url.split('/');
  prot = arr[0];
  dom = arr[2];
  path = arr.slice(3);
  return [prot, dom, path.join('/')];
};

tryHttps = function(url, tabId) {
  var domain, path, pdm, protocol;
  pdm = _getProtocol_Domain_Path(url);
  protocol = pdm[0];
  domain = pdm[1];
  path = pdm[2];
  if (indexOf.call(blacklist, url) < 0) {
    if (indexOf.call(blacklist, domain) >= 0) {
      return false;
    }
    if (protocol === 'http:') {
      if ((indexOf.call(httplist, domain) >= 0)) {
        console.log('already tried, no https for ' + domain);
        return false;
      }
      if ((indexOf.call(httpslist, domain) >= 0)) {
        return forward_to('https://' + [domain, path].join('/'), tabId);
      } else {
        if (_tryDomain(domain, path, tabId)) {
          return true;
        } else {
          return false;
        }
      }
    }
  }
};

forward_to = function(newUrl, tabId) {
  console.log('forwarding tab ' + tabId + ' to ' + newUrl);
  return chrome.tabs.update(tabId, {
    url: newUrl
  });
};

chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
  if (changeInfo) {
    if (changeInfo.url) {
      return tryHttps(changeInfo.url, tabId);
    }
  }
});

chrome.tabs.onCreated.addListener(function(tabId, changeInfo, tab) {
  if (changeInfo) {
    if (changeInfo.url) {
      return tryHttps(changeInfo.url, tabId);
    }
  }
});

//# sourceMappingURL=tryhttps.js.map
